# FXGC50_Fractals
#### Video Demo:  <URL HERE>
#### Description:

The Mandelbrot set, probably one of the most iconic images in all of mathematics. A complex and infinitely intricate fractal shape, it emerges from a deceptively simple mathematical formula: Z_n+1 = (Z_n)^2 + c, where Z_0 = 0+0i and c is (x_pixel) + (y_pixel)i. The set is defined by iteratively applying this formula, determining whether they remain bounded or escape to infinity based on the variable starting conditions. The black areas on this set are where the iterative formula converges to a point, and then the colour outside depends on the number of iterations to determine whether it will diverge to infinity. My aim for this project was to render an image of this classic representation of chaos theory on my FXCG-50 graphical calculator. Having a strong background in complex numbers, I was very confident in my ability to code the maths in this project. The main challenge was making all of this work on a calculator... 

Unfortunately, the official documentation on the calculator's software was non-existent. Luckily, this website has been researching the operating system and the hardware it runs on: https://prizm.cemetech.net/ . Almost all of my research on this project was done on this website, and I would say more time was spent trying to decipher the syscalls and parameters than actually coding. Take a very simple function, for example, PrintXY(). Even this simple function has some quirks, the worst of which is that the string it prints must start with 2 garbage characters that are used for different types of encoding. This made printing any kind of variables almost impossible, as I could not use typical string manipulation since their implementations of malloc() and free() don't work as documented so defining char* was impossible. Another quirk of PrintXY was that X was indexed at 1, whereas Y was indexed at 0. Also, this was one of the only functions to use these arbitrary coordinates, rather than pixel coordinates.

You can see how difficult it was to understand the simplest of functions, so you can imagine actually rendering something would be very difficult. This was made no easier by the fact that the only way of doing this was to directly read and write to the calculators VRAM. This resulted in many black screens and unresponsive keyboards in my testing... In the end though, the lifesaving functions of this project were the Bdisp() functions. These made it relatively easy to write direct pixel values in RGB 656 (yes, another quirk) to the VRAM and then force-update the screen to display the VRAM contents. This function was used everywhere, from rendering the set, to the axies, to the trace lines. It was my main method of interfacing with the display and displaying the maths that was going on in the background.

So now for an overview of the program and how to use it:

Plug your calculator into your computer, and press ALPHA + E to display the link menu. Press F2 to enter data receive mode. The calculator's main storage should then appear as a USB stick in your computer's file explorer. Copy over ONLY THE .g3a file to the calculator's main directory. 

Once you have completed the steps to get the program onto your calculator, go to the bottom of the main menu where you should see a new program called Fractals whose icon is the mandelbrot set. You can tell when you have it selected, because there will be a blue border around it. When you do, Press EXE.

This puts you on the program menu, with at this time only 2 options, Mandelbrot and Settings. We will cover the settings menu first.

Press F6 or the right arrow key to access the settings menu. 
The first setting is TRACE, which is a complex function that is on by default, and that I will go over in more detail at the end. Change this between on and off by pressing F1. 
The second setting is the MAX ITERATIONS. This determines how many times the program will loop over the complex iteration function, and also how many lines will be seen when rendering a TRACE. In general, lowering this value will lower the quality of the render, but will also lower the render time. In my testing I have found 20 to be the sweet spot, and I only ever changed it to get more traces. If you do want to change it, press F2. This will clear the value on the screen, and a flashing cursor will appear next to the text. Enter a value between 10 and 99 inclusive, and it will save it automatically. If you do not enter a valid input, it will default back to 20. 
The third setting is LIVE RENDER, which is on by default and will render the mandelbrot set with a scanline effect in real time. However, this does make the render marginally slower as computations are used to push the render to the screen from the VRAM. If you are using large MAX ITERATION values, you might want to turn this off. In doing so, when the set is rendering it will simply display text with the word 'Rendering...' on it. Change this between on and off by pressing F3.
The fourth setting is AXIES which simply will render a real and imaginary axis over the set once done, in half-unit increments. This is off by default but can be switched between on and off by pressing F4.
The final setting is the ADVANCED COLOUR setting. This uses a syscall to override the colour limitations of the display from the built-in 8 colours, to the full RGB 565 range. It is on by default, as it makes the renders look significantly better, but it will use significantly more memory and is very marginally slower. If you are getting errors or crashes, the first port of call should be turning this setting off by pressing F5.

The last section of the settings page is the info section, which can be accessed by pressing the right arrow or F6, and just links you to this readme file for those who got this file off a third-party website.

Go back to the main menu by pressing EXIT or the left arrow key. Now, you can press F1 to begin the render. With default settings, it should take about 25 seconds. If you have LIVE RENDER on, it will render down the screen in real-time. If you have it off, it will just display 'Rendering'. Once it has rendered, if you have AXIES on then white axies will be drawn to the screen. If you have ADVANCED COLOUR on, you should see a nice halo around the boundary of the set that reflects the number of iterations of the complex number to go beyond the critical value and spiral off to infinity. If you have this off, there will be a solid colour and no gradient. Now for the best bit, the TRACE. If you have it on, a single red pixel cursor will appear at the origin. This can be moved with the arrow keys, until you reach a specific area of interest. Then by pressing EXE you will see a selection of green lines and red dots, originating from the origin. This represents the path that a complex number took through its iterations in the formula, and was definitely the hardest function to implement. The red dots represent the history of the complex number locations in the complex plane, while the green lines draw chronological paths between them. Press EXE again to clear and you can move the cursor to another spot to explore the trace of!

This will often create mesmerizing geometric patterns, and I encourage you to just play around with it for a while. Choose some different areas on the render to see their traces, try to find the prettiest ones! Notice the patterns based on the colour of the render. Those in the black region will always converge and spiral to a point. Those on the outer edge will take a lot of iterations to spiral to infinity, but those far away from the boundary fly off almost instantly. Try the left bulb, see how it creates a periodic sequence of period 2 (a single line)?. Try the bulbs on the top, going from right to left. You start with a period of 3, them 5, then 8, then 13... what is the Fibonacci sequence doing here? Curious... I recommend just scouting the outer areas of the set, and admiring the patterns and paths created. 

So, that is a complete summary of the features of this program. Hopefully, it has inspired you to look a bit deeper into the method, or at least you should have gained a bit more appreciation for the beauty of mathematics. If you want to show your support, consider watching this repository. If this gains enough interest, I will add a feature that renders the corresponding Julia set of a point gathered by a trace. This will take a lot of effort though, so I want to ensure that enough people are interested first.
